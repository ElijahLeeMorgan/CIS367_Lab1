<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab1</title>
    <style>
        #controls {
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        button {
            margin: 5px;
        }
        #color-input {
            margin: 5px;
        }
        canvas {
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
            width: 500px;
            height: 500px;
        }
    </style>
    <canvas id="webgl-canvas" width="500" height="500"></canvas>
</head>
<body>
<div id="controls">
    <button onclick="setShape('p')">Point</button>
    <button onclick="setShape('l')">Line</button>
    <button onclick="setShape('t')">Triangle</button>
    <button onclick="setShape('r')">Rectangle</button>
    <button onclick="setShape('d')">Disk</button>
    <button onclick="setColor([1, 0, 0, 1])">Red</button>
    <button onclick="setColor([0, 1, 0, 1])">Green</button>
    <button onclick="setColor([0, 0, 1, 1])">Blue</button>
    <input id="color-input" type="text" placeholder="Enter RGB (e.g., 255,0,0)">
    <button onclick="setCustomColor()">Set Custom Color</button>
    <button onclick="clearCanvas()">Clear</button>
</div>
<script>
const vertexShaderSource = `
    attribute vec2 aPosition;
    uniform vec2 dim;
    vec2 transformedPosition;
    attribute vec4 vColor;
    varying vec4 fColor;

    void main() {
        fColor = vColor;
        transformedPosition =(vec2(2.0,-2.0) * aPosition) / dim + vec2(-1.0,1.0);
        gl_Position = vec4(transformedPosition, 0.0, 1.0); 
        gl_PointSize = 5.0;
    }
`;
</script>
<script>
const fragmentShaderSource = `
    precision mediump float;
    varying vec4 fColor;

    void main() {
        gl_FragColor = fColor; 
    }
`;
</script>
<script type="text/javascript" src="setupShader.js"></script>

<script>

// Button functions
function setShape(shape) {
    currentShape = shape;
}
function setColor(color) {
    currentColor = color;
    draw();
}
function setCustomColor() {
    const colorInput = document.getElementById('color-input').value;
    const rgb = colorInput.split(',').map(Number);
    if (rgb.length === 3 && rgb.every(c => c >= 0 && c <= 255)) {
        currentColor = [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, 1];
    } else {
        alert('Please enter valid RGB values between 0 and 255');
    }
}
function clearCanvas() { 
    gl.clear(gl.COLOR_BUFFER_BIT);
    shapeHistory.length = 0;
}

// Pass Canvas Dimensions to Shader
const dimLocation = gl.getUniformLocation(program, 'dim');
gl.uniform2f(dimLocation, canvas.width, canvas.height);

// Init Position buffer object
const positionBuffer = gl.createBuffer();
const aPositionLocation = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(aPositionLocation);

// Init Color buffer object
const colorBuffer = gl.createBuffer();
const aColorLocation = gl.getAttribLocation(program, 'vColor');
gl.enableVertexAttribArray(aColorLocation);

// State variables. Should be contained somehow, but this works.
let currentShape = 'p'; // Default shape: point
let currentColor = [1, 0, 0, 1]; // Default color: red
let shapeHistory = []; // array of objects to be drawn

class Point {
    constructor(x, y, color) {
        this.name = 'Point'; //Classifer names weren't working, so I'm using instance names even though they're all the same.
        this.verts = [x, y]; //Now I think about it, I probably could've used drawType.
        this.colors = color;
        this.drawType = gl.POINTS;
    }
}

class Line {
    constructor(x, y, color) {
        this.name = 'Line';
        this.verts = [x, y]; // Only x/y sets of 2 will be rendered
        this.colors = color; // Same applies to colors ^^
        this.drawType = gl.LINES;
    }
}

class Triangle {
    constructor(x, y, color) {
        this.name = 'Triangle';
        this.verts = [x, y]; // Only x/y sets of 3 will be rendered
        this.colors = color; // Same applies to colors ^^
        this.drawType = gl.TRIANGLES;
    }
}

class _CircleLike {
    constructor(x, y, color, radius, numPoints, drawType) {
        // -- Start AI code -- + Serveral generations of human and AI edits.
        this.verts = this.genCirclePoints(x, y, radius, numPoints); // Generate vertices
        this.colors = this.genColorArray(color, numPoints); // Generate colors
        this.drawType = drawType; // Set draw type
    }

    genCirclePoints(x, y, radius, numPoints) {
        if (numPoints < 3 || radius <= 0) {
            return [];
        }

        const points = [];
        for (let i = 0; i < numPoints; i++) {
            const angle = (Math.PI * 2 * i) / numPoints;
            const px = x + Math.cos(angle) * radius;
            const py = y + Math.sin(angle) * radius;
            points.push(px, py);
        }
        return points;
    }

    genColorArray(color, times) {
        return Array(times).fill(color).flat(); // Flatten the array for consistency
    }
    // -- End AI code --
}

class Square extends _CircleLike {
    constructor(x, y, color, radius) {
        // Call parent constructor with specific parameters for a square
        super(x, y, color, radius, 4, gl.TRIANGLE_FAN);
        this.name = 'Square';this.name = 'Square';
    }
}

class Disk extends _CircleLike {
    constructor(x, y, color, radius) {
        // Call parent constructor with specific parameters for a disk
        super(x, y, color, radius, 100, gl.TRIANGLE_FAN);
        this.name = 'Disk';
    }
}

// -- Start AI code --
function checkHistory(name) {
    // checks if last object in shapeHistory is of the same type
    if (shapeHistory.length === 0) {
        return true;
    } else {
        return shapeHistory[shapeHistory.length - 1].name !== name;
    }
}

function updateHistory(x, y, name, classToPush) {
    if (checkHistory(name)) {
        // Create a new object and push it to shapeHistory
        shapeHistory.push(new classToPush(x, y, currentColor));
        console.log(`New ${name} Object Created`);
        return true;
    } else {
        // Update the last object in shapeHistory
        const lastObject = shapeHistory[shapeHistory.length - 1];
        lastObject.verts.push(x, y);
        lastObject.colors.push(...currentColor);
        console.log(`${name} Object Updated`);
        return false;
    }
    console.log('Something went wrong!');
}
// -- End AI code --

// Shape drawing functions
function addPoint(x, y) {
    updateHistory(x, y, Point.name, Point);
}

function addLine(x, y) {
    // TODO - Geometry and Color for Line (1')
    // To draw a line, click on the canvas to specify the start point and end point.
    // Each line is created after two points are clicked.
    updateHistory(x, y, Line.name, Line);
}

function addTriangle(x, y) {
    // TODO - Geometry and Color for Triangle (1')
    // To draw triangles, click on the canvas to specify the vertices.
    // Each triangle is created after every three points are clicked.
    updateHistory(x, y, Triangle.name, Triangle);
}

function addSquare(x, y, radius) {
    // TODO - Geometry and Color for Square (1')
    // To draw squares, click on the canvas to place the center of the square at the clicked position.
    // You can specify the size of the square as desired.

    updateHistory(x, y, Square.name, Square);
}

function addDisk(x, y) {
    // TODO - Geometry and Color for Disk (1')
    // To draw disks, click on the canvas to place the center of the disk at the clicked position.
    // You can specify the radius of the disk as desired.
    
    // May have to include center point in the diskVert array.
    // If there's a hole in the middle of the disk, uncomment this.
    //diskVert.push(x, y); // Pushes center point first.
    updateHistory(x, y, Disk.name, Disk);
}

// Debug helper function
function printInfo(x, y) {
    console.log(`Clicked at (${x}, ${y})`);
    console.log(`Current Shape: ${currentShape}`);
    console.log(`Current Color: ${currentColor}`);
    //console.log(`Object History: ${shapeHistory}`);
    console.log(`Current Object: ${shapeHistory[shapeHistory.length - 1].name}`);
    console.log(`Current Object Vertices: ${shapeHistory[shapeHistory.length - 1].verts}`);
    console.log(`Current Object Colors: ${shapeHistory[shapeHistory.length - 1].colors}`);
}

// WebGL helper draw function
function GLdraw(posArr, colArr, drawType) {
    console.log(`DRAWTYPE: ${drawType}`);
    console.log(`COLOR ARRAY: ${colArr} LENGTH: ${colArr.length} ISARRAY: ${colArr.constructor === Array}`);
    console.log(`POSITION ARRAY: ${posArr} LENGTH: ${posArr.length} ISARRAY: ${posArr.constructor === Array}`);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(aColorLocation, 4, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colArr), gl.STATIC_DRAW);
    
    // Give point positions.
    // Takes JS point data (2 floats / vec2) and pushes it to the shader.
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(aPositionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(posArr), gl.STATIC_DRAW);


    // Draw points
    gl.drawArrays(drawType, 0, posArr.length/2);

}

function draw() {
    gl.clearColor(1, 1, 0.75, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    shapeHistory.forEach(element => {
        console.log(`${element.name} Drawn`);
        switch (element.name) {
            case 'Point':
                GLdraw(element.verts, element.colors, element.drawType);
                break;
            case 'Line':
                GLdraw(element.verts, element.colors, element.drawType);
                break;
            case 'Triangle':
                GLdraw(element.verts, element.colors, element.drawType);
                break;
            case 'Square':
                GLdraw(element.verts, element.colors, element.drawType);
                break;
            case 'Disk':
                GLdraw(element.verts, element.colors, element.drawType);
                break;
        }
    });

    // TODO - Vertex Colors (1')
    // Currently colors are uniform, change the corresponding code to make different colors for shapes
    // Line and Triangle colors should be per vertex
    // Disk and Squre colors should be per shape
    //const colorLocation = gl.getUniformLocation(program, 'vColor');
    //gl.uniform4fv(colorLocation, currentColor);

    //TODO, handle out of order shapes.
    // Idea 1: Use a aray to keep track of type of shape, and GL position. gl.drawArrays(drawType, startingPos, countToStopAt)
    // Idea 2: make seprate buffers for all shapes, and draw them in order.
    
    //NOTES
    // Idea 1 is cool, but sounds overengineered. Idea 2 is simple, but may be slow.
    // Idea 2 may draw shapes in incorrect order.
    // Attempting idea 1 first.

    //GLdraw(pointVert, pointCol, gl.POINTS, 2, 0);
    //GLdraw(lineVert, lineCol, gl.LINES, 2, pointVert.length/2);

    // TODO - Draw other shapes (2')
    // You can change buffer data this way:
    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(line_vertices), gl.STATIC_DRAW);
    // gl.drawArrays(gl.LINES, 0, line_vertices.length/2);
    // Or you can use drawElements with indices
}

// Mouse click event handler
canvas.addEventListener('mousedown', (event) => {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    switch (currentShape) {
        case 'p':
            addPoint(x, y);
            break;
        case 'l':
            addLine(x, y);
            break;
        case 't':
            addTriangle(x, y);
            break;
        case 'q':
            addSquare(x, y, 10);
            break;
        case 'd':
            addDisk(x, y);
            break;
    }
    printInfo(x, y); //Debugging info
    draw();
});

// Clear the canvas
gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(1, 1, 0.75, 1);
gl.clear(gl.COLOR_BUFFER_BIT);
</script>
</body>
</html>