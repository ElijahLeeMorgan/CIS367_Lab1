<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab1</title>
    <style>
        #controls {
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        button {
            margin: 5px;
        }
        #color-input {
            margin: 5px;
        }
        canvas {
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
            width: 500px;
            height: 500px;
        }
    </style>
    <canvas id="webgl-canvas" width="500" height="500"></canvas>
</head>
<body>
<div id="controls">
    <button onclick="setShape('p')">Point</button>
    <button onclick="setShape('l')">Line</button>
    <button onclick="setShape('t')">Triangle</button>
    <button onclick="setShape('r')">Rectangle</button>
    <button onclick="setShape('d')">Disk</button>
    <button onclick="setColor([1, 0, 0, 1])">Red</button>
    <button onclick="setColor([0, 1, 0, 1])">Green</button>
    <button onclick="setColor([0, 0, 1, 1])">Blue</button>
    <input id="color-input" type="text" placeholder="Enter RGB (e.g., 255,0,0)">
    <button onclick="setCustomColor()">Set Custom Color</button>
    <button onclick="clearCanvas()">Clear</button>
</div>
<script>
const vertexShaderSource = `
    attribute vec2 aPosition;
    uniform vec2 dim;
    vec2 transformedPosition;
    attribute vec4 vColor;
    varying vec4 fColor;

    void main() {
        fColor = vColor;
        transformedPosition =(vec2(2.0,-2.0) * aPosition) / dim + vec2(-1.0,1.0);
        gl_Position = vec4(transformedPosition, 0.0, 1.0); 
        gl_PointSize = 5.0;
    }
`;
</script>
<script>
const fragmentShaderSource = `
    precision mediump float;
    varying vec4 fColor;

    void main() {
        gl_FragColor = fColor; 
    }
`;
</script>
<script type="text/javascript" src="setupShader.js"></script>

<script>

// Button functions
function setShape(shape) {
    currentShape = shape;
}
function setColor(color) {
    currentColor = color;
}
function setCustomColor() {
    const colorInput = document.getElementById('color-input').value;
    const rgb = colorInput.split(',').map(Number);
    if (rgb.length === 3 && rgb.every(c => c >= 0 && c <= 255)) {
        currentColor = [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, 1];
    } else {
        alert('Please enter valid RGB values between 0 and 255');
    }
}
function clearCanvas() { // Probably 1 Million better ways to do this, but it works.
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    pointVert.length = 0;
    lineVert.length = 0;
    triangleVert.length = 0;
    squareVert.length = 0;
    diskVert.length = 0;

    pointCol.length = 0;
    lineCol.length = 0;
    triangleCol.length = 0;
    squareCol.length = 0;
    diskCol.length = 0;

    numPoint = 0;
    numLine = 0;
    numTriangle = 0;
    numSquare = 0;
    numDisk = 0;
}

// Pass Canvas Dimensions to Shader
const dimLocation = gl.getUniformLocation(program, 'dim');
gl.uniform2f(dimLocation, canvas.width, canvas.height);

// Init Position buffer object
const positionBuffer = gl.createBuffer();
const aPositionLocation = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(aPositionLocation);

// Init Color buffer object
const colorBuffer = gl.createBuffer();
const aColorLocation = gl.getAttribLocation(program, 'vColor');
gl.enableVertexAttribArray(aColorLocation);

// State variables
let currentShape = 'p'; // Default shape: point
let currentColor = [1, 0, 0, 1]; // Default color: red
let numPoint=0;
let numLine=0;
let numTriangle=0;
let numSquare=0;
let numDisk=0;

const pointVert = [];
const lineVert = [];
const triangleVert = [];
const squareVert = [];
const diskVert = [];

const pointCol = [];
const lineCol = [];
const triangleCol = [];
const squareCol = [];
const diskCol = [];

// Shape drawing helper functions
// --Start AI code--
function genCirclePoints(x, y, radius, numPoints) {
    if (numPoints < 3 || radius <= 0) {
        return [];
    }

    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const angle = Math.PI * 2 * i / numPoints;
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        pointCol.push(currentColor);
        //pointCol.push(currentColor); //FIXME Double check if this is needed, or an AI hallucination.
        points.push(px, py);
    }
    return points;
}
// --End AI code--

// Shape drawing functions
function addPoint(x, y) {
    pointVert.push(x, y);
    pointCol.push(...currentColor);
    numPoint ++;
    // TODO - Color for Point (1'). Done.
}



// Debug helper function
function printInfo(x, y) {
    console.log(`Clicked at (${x}, ${y})`);
    console.log(`Current Shape: ${currentShape}`);
    console.log(`Current Color: ${currentColor}`);
    console.log(`Number of Points: ${numPoint}`);
    console.log(`JS Current Point Vertices: ${pointVert}`);
    console.log(`JS Current Point Colors: ${pointCol}`);
}

function addLine(x, y) {
    // TODO - Geometry and Color for Line (1')
    // To draw a line, click on the canvas to specify the start point and end point.
    // Each line is created after two points are clicked.
    lineVert.push(x, y);
    lineCol.push(...currentColor);
    numLine = Math.floor(lineVert.length/2);
}

function addTriangle(x, y) {
    // TODO - Geometry and Color for Triangle (1')
    // To draw triangles, click on the canvas to specify the vertices.
    // Each triangle is created after every three points are clicked.
    triangleVert.push(x, y);
    triangleCol.push(...currentColor);
    numTriangle = Math.floor(lineVert.length/3);
}

function addSquare(x, y, radius) {
    // TODO - Geometry and Color for Square (1')
    // To draw squares, click on the canvas to place the center of the square at the clicked position.
    // You can specify the size of the square as desired.

    squareVert.push(genCirclePoints(x, y, radius, 4))
    numSquare ++;
}

function addDisk(x, y) {
    // TODO - Geometry and Color for Disk (1')
    // To draw disks, click on the canvas to place the center of the disk at the clicked position.
    // You can specify the radius of the disk as desired.
    
    // May have to include center point in the diskVert array.
    // If there's a hole in the middle of the disk, uncomment this.
    //diskVert.push(x, y); // Pushes center point first.
    diskVert.push(genCirclePoints(x, y, 10, 100));
    numDisk ++;
}

function draw() {
    // WebGL drawing are not incremental,
    // You should keep all previous geometry data 
    // and redraw everything when calling draw()
    gl.clearColor(1, 1, 0.75, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // TODO - Vertex Colors (1')
    // Currently colors are uniform, change the corresponding code to make different colors for shapes
    // Line and Triangle colors should be per vertex
    // Disk and Squre colors should be per shape
    //const colorLocation = gl.getUniformLocation(program, 'vColor');
    //gl.uniform4fv(colorLocation, currentColor);

    // Give point colors.
    // Takes JS color data (4 floats / vec4) and pushes it to the shader.
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(aColorLocation, 4, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pointCol), gl.STATIC_DRAW);

    // Give point positions.
    // Takes JS point data (2 floats / vec2) and pushes it to the shader.
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(aPositionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pointVert), gl.STATIC_DRAW);


    // Draw points
    gl.drawArrays(gl.POINTS, 0, pointVert.length/2);

    // TODO - Draw other shapes (2')
    // You can change buffer data this way:
    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(line_vertices), gl.STATIC_DRAW);
    // gl.drawArrays(gl.LINES, 0, line_vertices.length/2);
    // Or you can use drawElements with indices
}

// Mouse click event handler
canvas.addEventListener('mousedown', (event) => {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    switch (currentShape) {
        case 'p':
            addPoint(x, y);
            break;
        case 'l':
            addLine(x, y);
            break;
        case 't':
            addTriangle(x, y);
            break;
        case 'q':
            addSquare(x, y, 10);
            break;
        case 'd':
            addDisk(x, y);
            break;
    }
    printInfo(x, y); //Debugging info
    draw();
});

// Clear the canvas
gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(1, 1, 0.75, 1);
gl.clear(gl.COLOR_BUFFER_BIT);
</script>
</body>
</html>